
%code requires {
#include <cstdlib> // for atoi
#include <iostream>
#include <string>
#include <map>
#include "colorout.hpp"
#include "driver.hpp"
#include "tree.hpp"
#include "engine.hpp"
#define NOTHING		struct value temp;temp.use="none";

using namespace std;

//-- Lexer prototype required by bison
int yylex(); 

// Global variables for printing in pretty colors
extern colorout resout;
extern colorout errout;
}

  /* Everything in this block only goes in the bison file. */
%code {

Driver* driver = new Driver();
Engine* engine = new Engine();



// Error function that bison will call
void yyerror(const char *description) { 
  errout << description << endl; 
}

// Global variable to indicate done-ness
bool keepgoing = true;



}

  /* Tell bison to give descriptive error messages. */
%error-verbose

  /* These are the different "semantic values" that a token can have. */
%union {
  int ival;
  float fval; 
  char sym;
  char* id;
  TreeNode *tval;
};

  /* These are the basic token types, organized by what kind
   * of semantic value they can have. */
%token <ival> INT
%token <fval> FLOAT 
%token <id> STRING
%token <id> VAR
%token <id> IDEN
%token <ival> BOOL
%token <sym> OPA OPM 
%token LP RP STOP 
%token ASSGN
%token AND
%token OR
%token GTH
%token LTH
%token GTHEQ;
%token LTHEQ;
%token EQ
%token NEQ
%token SOP
%token EOP
%token SOB
%token EOB
%token SOCB
%token EOCB
%token RETURN IF FOR ELSE WHILE FUNC KOR STRUCT RANGE 

  /* These are the non-terminal names that have values. */
%type <tval> exp  stmt factor 

//-- GRAMMAR RULES ---------------------------------------
%%
  /* Note: YYACCEPT is a macro that tells bison to stop parsing. */
S: stmt {NOTHING
  TreeNode *root = new TreeNode(temp,OPERATIONS(ROOT),$1,NULL,NULL,NULL);
  engine->execute(root);
  YYACCEPT;
}
|       { keepgoing = false; }

stmt: exp STOP { $$ = $1; }
| IDEN VAR ASSGN exp STOP {
  struct value temp;
  temp.use = "identifier";
  struct value temp2;
  temp2.v.s = $2;
  temp2.use = "string";
  TreeNode* second = new TreeNode(temp2,OPERATIONS(VARIABLE));
  $$ = new TreeNode(temp,OPERATIONS(ASSIGN),NULL,second,$4,NULL);
}

exp: exp OPA factor      { 
  struct value temp;
  temp.use = "identifier";
  $$ = new TreeNode(temp,OPERATIONS(SUM),$1,$3,NULL,NULL);
 }
| factor               { $$ = $1; }

factor: INT            { 
  struct value temp;
  temp.v.i = $1;
  temp.use = "integer";
  $$ = new TreeNode(temp,OPERATIONS(CONSTANT));
 }
 | VAR {
  struct value temp;
  int val  = engine->driver->getInt($1);
  temp.v.i = val;
  temp.use = "integer";
  $$ = new TreeNode(temp,OPERATIONS(CONSTANT));
 }


%%
// These are the colored output streams to make things all pretty.
colorout resout(1, 'u');
colorout errout(2, 'r');

//-- FUNCTION DEFINITIONS ---------------------------------
int main()
{
  // This checks whether the output is a terminal.
  bool tty = isatty(0) && isatty(2);

  while (keepgoing) {
    if (tty) cerr << "> " << flush;
    yyparse();
  }
  if (tty) cerr << "Goodbye" << endl;
  return 0;
}

void printbin(int n) {
  if (n < 0) { 
    resout << '-'; 
    n = -n; 
  }
  int bit = 1;
  while (bit > 0 && bit*2 <= n) bit *= 2;
  while (bit > 0) {
    if (bit <= n) {
      n -= bit;
      resout << '1';
    }
    else resout << '0';
    bit /= 2;
  }
  return;
}