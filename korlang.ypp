
%code requires {
#include <cstdlib> // for atoi
#include <iostream>
#include <string>
#include <map>
#include "colorout.hpp"
#include "driver.hpp"
#include "tree.hpp"
#include "engine.hpp"
#define NOTHING		struct value temp;temp.use="none";

using namespace std;

//-- Lexer prototype required by bison
int yylex(); 

// Global variables for printing in pretty colors
extern colorout resout;
extern colorout errout;
}

  /* Everything in this block only goes in the bison file. */
%code {

Driver* driver = new Driver();
Engine* engine = new Engine();



// Error function that bison will call
void yyerror(const char *description) { 
  errout << description << endl; 
}

// Global variable to indicate done-ness
bool keepgoing = true;



}

  /* Tell bison to give descriptive error messages. */
%error-verbose

  /* These are the different "semantic values" that a token can have. */
%union {
  int ival;
  float fval; 
  char sym;
  char* id;
  TreeNode *tval;
};

  /* These are the basic token types, organized by what kind
   * of semantic value they can have. */
%token <ival> INT
%token <fval> FLOAT 
%token <id> STRING
%token <id> VAR
%token <id> IDEN
%token <ival> BOOL
%token <sym> OPA OPM 
%token LP RP STOP 
%token COMMA
%token ASSGN MUL_ASSIGN MOD_ASSIGN DIV_ASSIGN SUB_ASSIGN ADD_ASSIGN
%token AND
%token OR
%token GTH
%token LTH
%token GTHEQ;
%token LTHEQ;
%token EQ
%token NEQ
%token SOP
%token EOP
%token SOB
%token EOB
%token SOCB
%token EOCB
%token RETURN_T IF FOR ELSE WHILE FUNC KOR STRUCT RANGE BREAK_T 

  /* These are the non-terminal names that have values. */
%type <tval> exp  stmts factor assignment_operator stmt term logical_operators logical_or_operations logical_operations function_call params variable_list
%start S

//-- GRAMMAR RULES ---------------------------------------
%%
  /* Note: YYACCEPT is a macro that tells bison to stop parsing. */
S: stmts 
  {NOTHING
  TreeNode *root = new TreeNode(temp,OPERATIONS(ROOT),$1,NULL,NULL,NULL);
  engine->execute(root);
  YYACCEPT;
}
|       { keepgoing = false; }


stmts: stmt
  {NOTHING
  $$ = new TreeNode(temp,OPERATIONS(STMT_LIST),NULL,$1,NULL,NULL);
  }
|stmts stmt 
{NOTHING
$$ = new TreeNode(temp,OPERATIONS(STMT_LIST),$1,$2,NULL,NULL);
}


stmt: exp STOP 
  {NOTHING
  $$ = new TreeNode(temp,OPERATIONS(EXPRESSION),$1,NULL,NULL,NULL);
  }
| IDEN VAR ASSGN exp STOP {
  struct value temp;
  temp.use = "identifier";
  struct value temp2;
  temp2.v.s = $2;
  temp2.use = "string";
  TreeNode* second = new TreeNode(temp2,OPERATIONS(VARIABLE));
  $$ = new TreeNode(temp,OPERATIONS(DECLARATION),NULL,second,$4,NULL);
}
| VAR assignment_operator exp STOP{
  struct value temp;
  temp.use =  "identifier";
  temp.v.s = $1;
$$ = new TreeNode(temp,OPERATIONS(ASSIGNMENT),NULL,$2,$3,NULL);}
| FOR SOCB stmts EOCB {
  struct value temp;
  temp.use = "identifier";
  $$ = new TreeNode(temp,OPERATIONS(LOOP),$3,NULL,NULL,NULL);
}
| FOR logical_operations SOCB stmts EOCB {
  struct value temp;
  temp.use = "identifier";
  $$ = new TreeNode(temp,OPERATIONS(LOOP),$2,$4,NULL,NULL);
}
| FOR stmt  logical_operations STOP stmt  SOCB stmts EOCB {
  struct value temp;
  temp.use = "identifier";
  $$ = new TreeNode(temp,OPERATIONS(LOOP),$2,$3,$5,$7);
}
|logical_operations STOP{NOTHING
$$ = new TreeNode(temp,OPERATIONS(AND_LOGIC),$1,NULL,NULL,NULL);
}
| IF exp SOCB stmts EOCB{NOTHING
$$ = new TreeNode(temp,OPERATIONS(IF_LOGIC),$2,$4,NULL,NULL);
}
|IF exp SOCB stmts EOCB ELSE SOCB stmts EOCB{NOTHING
$$ = new TreeNode(temp,OPERATIONS(IF_ELSE_LOGIC),$2,$4,$8,NULL);
}

| FUNC VAR SOP variable_list EOP SOCB  stmts EOCB {
  struct value temp;
  temp.v.s = $2;
  temp.use = "identifier";
  $$ = new TreeNode(temp,OPERATIONS(FUNCTION_DEC),$4,$7,NULL,NULL);
}
| FUNC VAR SOP  EOP SOCB  stmts EOCB {
  struct value temp;
  temp.v.s = $2;
  temp.use = "identifier";
  $$ = new TreeNode(temp,OPERATIONS(FUNCTION_DEC),NULL,$6,NULL,NULL);
}
| BREAK_T STOP {NOTHING
  $$ = new TreeNode(temp,OPERATIONS(BREAK));
}
|
RETURN_T STOP {NOTHING
  $$ = new TreeNode(temp,OPERATIONS(RETURN));
}
|
RETURN_T exp STOP {NOTHING
  $$ = new TreeNode(temp,OPERATIONS(RETURN),$2,NULL,NULL,NULL);
}


variable_list : VAR {NOTHING
  struct value temp1;
  temp1.v.s = $1;
  temp1.use = "identifier";
  auto tn = new TreeNode(temp1,OPERATIONS(VAR_NAME));
  $$ = new TreeNode(temp,OPERATIONS(VAR_LIST),NULL,tn,NULL,NULL); 
}
| variable_list COMMA VAR {NOTHING
struct value temp1;
  temp1.v.s = $3;
  temp1.use = "identifier";
  auto tn = new TreeNode(temp1,OPERATIONS(VAR_NAME));
  $$ = new TreeNode(temp,OPERATIONS(VAR_LIST),$1,tn,NULL,NULL);
}

function_call : VAR SOP EOP {
  struct value temp;
  temp.v.s = $1;
  $$ = new TreeNode(temp,OPERATIONS(FUNCTION));
}
| VAR SOP params EOP {
  struct value temp;
  temp.v.s = $1;
  $$= new TreeNode(temp,OPERATIONS(FUNCTION),$3,NULL,NULL,NULL);
}



params : exp {NOTHING $$ = new TreeNode(temp,OPERATIONS(PARAMETERS),NULL,$1,NULL,NULL); }
| params COMMA exp { NOTHING 
  $$ = new TreeNode(temp,OPERATIONS(PARAMETERS),$1,$3,NULL,NULL);
  }



exp: exp OPA term      { 
  struct value temp;
  temp.use = "identifier";
  OPERATIONS op = OPERATIONS(SUM);
  if ($2 == '-') op = OPERATIONS(SUB); 

  $$ = new TreeNode(temp,op,$1,$3,NULL,NULL);
 }
| term               { $$ = $1; }
|logical_operations  { $$ = $1; }

term : term OPM factor {
  struct value temp;
  temp.use = "identifier";
  OPERATIONS op = OPERATIONS(MULTIPLY);
  if ($2 == '/') op = OPERATIONS(DIVIDE);
  if ($2 == '%') op = OPERATIONS(MOD); 
  $$ = new TreeNode(temp,op,$1,$3,NULL,NULL);

}
| factor

factor: INT            { 
  struct value temp;
  temp.v.i = $1;
  temp.use = "integer";
  $$ = new TreeNode(temp,OPERATIONS(CONSTANT));
 }
 |STRING{
   struct value temp;
   temp.v.s = $1;
   temp.use = "string";
   $$ = new TreeNode(temp,OPERATIONS(CONSTANT));
 }
 | SOP exp EOP { $$ = $2;}
 | VAR {
  struct value temp;
  temp.v.s = $1;
  temp.use = "integer";
  $$ = new TreeNode(temp,OPERATIONS(VARIABLE));
 }
 | function_call  {  $$ = $1;}


 logical_operators:
 exp LTH exp {NOTHING
  $$ = new TreeNode(temp,OPERATIONS(LTH_LOGIC),$1,$3,NULL,NULL);
 }
 |exp GTH exp {NOTHING
 $$ = new TreeNode(temp,OPERATIONS(GTH_LOGIC),$1,$3,NULL,NULL);
 }
 |exp LTHEQ exp {NOTHING
 $$ = new TreeNode(temp,OPERATIONS(LTHEQ_LOGIC),$1,$3,NULL,NULL);
 }
 |exp GTHEQ exp {NOTHING
 $$ = new TreeNode(temp,OPERATIONS(GTHEQ_LOGIC),$1,$3,NULL,NULL);
 }
 |exp EQ exp{NOTHING
 $$ = new TreeNode(temp,OPERATIONS(EQ_LOGIC),$1,$3,NULL,NULL);}
 |exp NEQ exp{NOTHING
 $$ = new TreeNode(temp,OPERATIONS(NEQ_LOGIC),$1,$3,NULL,NULL);}
 |BOOL{
   struct value temp;
   temp.use = "boolean";
   temp.v.i = $1;
   $$ = new TreeNode(temp,OPERATIONS(CONSTANT));
 }
 |exp{NOTHING
 $$ = new TreeNode(temp,OPERATIONS(EXPRESSION),$1,NULL,NULL,NULL);
 }
 |SOP logical_operations EOP {$$ = $2; }


 logical_operations:
 logical_or_operations{NOTHING
 $$ = new TreeNode(temp,OPERATIONS(AND_LOGIC),$1,NULL,NULL,NULL);
 }
 | logical_operations AND logical_or_operations{NOTHING
 $$ = new TreeNode(temp,OPERATIONS(AND_LOGIC),$1,$3,NULL,NULL);
 }

 logical_or_operations:
 logical_or_operations  OR logical_operations{NOTHING
 $$ = new TreeNode(temp,OPERATIONS(OR_LOGIC),$1,$3,NULL,NULL);
 }
 |logical_operators{NOTHING
 $$ = new TreeNode(temp,OPERATIONS(LOGIC),$1,NULL,NULL,NULL);
 }




 assignment_operator :
  ASSGN
	{
		struct value temp;
		temp.v.s = "=";
		temp.use = "string";
		$$ = new TreeNode(temp,OPERATIONS(ASSIGNMENT_OPERATOR));
	}
	| MUL_ASSIGN
	{
		struct value temp;
		temp.v.s = "*=";
		temp.use = "string";
		$$ = new TreeNode(temp,OPERATIONS(ASSIGNMENT_OPERATOR));;
	}
	| DIV_ASSIGN
	{
		struct value temp;
		temp.v.s = "/=";
		temp.use = "string";
		$$ = new TreeNode(temp,OPERATIONS(ASSIGNMENT_OPERATOR));;
	}
	| MOD_ASSIGN
	{
		struct value temp;
		temp.v.s = "%=";
		temp.use = "string";
		$$ = new TreeNode(temp,OPERATIONS(ASSIGNMENT_OPERATOR));;
	}
	| ADD_ASSIGN
	{
		struct value temp;
		temp.v.s = "+=";
		temp.use = "string";
		$$ = new TreeNode(temp,OPERATIONS(ASSIGNMENT_OPERATOR));;
	}
	| SUB_ASSIGN
	{
		struct value temp;
		temp.v.s = "-=";
		temp.use = "string";
		$$ = new TreeNode(temp,OPERATIONS(ASSIGNMENT_OPERATOR));;
	}
	;
 


%%
// These are the colored output streams to make things all pretty.
colorout resout(1, 'u');
colorout errout(2, 'r');

//-- FUNCTION DEFINITIONS ---------------------------------
int main()
{
  // This checks whether the output is a terminal.
  bool tty = isatty(0) && isatty(2);

  while (keepgoing) {
    if (tty) cerr << "> " << flush;
    yyparse();
  }
  if (tty) cerr << "Goodbye" << endl;
  return 0;
}

void printbin(int n) {
  if (n < 0) { 
    resout << '-'; 
    n = -n; 
  }
  int bit = 1;
  while (bit > 0 && bit*2 <= n) bit *= 2;
  while (bit > 0) {
    if (bit <= n) {
      n -= bit;
      resout << '1';
    }
    else resout << '0';
    bit /= 2;
  }
  return;
}